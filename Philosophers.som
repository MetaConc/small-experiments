class DiningPhilosophersApp usingPlatform: platform = Value (
| private Array     = platform kernel Array.
  private actors    = platform actors.
  private Vector    = platform kernel Vector.
|)(
  
  public class ConditionalVars = (
   | private waitingQueue = Vector new.
   |)(

   public createPromise = (
    | pair p r |
        pair := actors createPromisePair.
        r := pair resolver.
        p := pair promise.
        waitingQueue append: r.
        ^ p
   )

   public resolvePromise = (
    | r |
      (waitingQueue size > 0)
      ifTrue: [
        r := waitingQueue at: 1.
        r resolve: true.
        waitingQueue removeFirst.
        'resolve promise' println.
      ]
    )
  )

  public class Waiter new: forks = (
  | private size = forks.
    private available = Array new: size.
    private cd = Array new: size.
  |
  )(

  public initForks = (
    available doIndexes: [:i |
    available at: i put: true.
    ]
  )

 public pickUpForks: i = (
 | left right p1 p2 av1 av2 |
   left :=  available at: i.
   right := available at: ((i % size) + 1).
   ('pick left ' + i +' '+left) println.
   ('pick right ' + ((i % size) + 1) +' '+right) println.

   (left = right)
    ifTrue: [
      'pick up forks' println.
      available at: i put: false.
      available at: ((i % size) + 1) put: false.
    ]
    ifFalse: [
    | condVar1 condVar2 |
      'no forks available' println.
      condVar1 := ConditionalVars new.
      condVar2 := ConditionalVars new.
      
      p1 := condVar1 createPromise.
      p2 := condVar2 createPromise.
      
      cd at: i put: condVar1.
      cd at: ((i % size) + 1) put: condVar2.

      (p1, p2) whenResolved: [: value |
           'resolved both promises' println.
            pickUpForks: i.
      ]
    ]
  )

  public putDownForks: i = (
    ('-putDownForks '+ i) println.
    ('putDownForks '+ ((i % size) + 1)) println.
    available at: i put: true.
    available at: ((i % size) + 1) put: true.
    (cd size > 0)
    ifTrue: [
      | condVar1 condVar2 |
      condVar1 := cd at: i.
      condVar2 := cd at: ((i % size) + 1).
      condVar1 resolvePromise.
      condVar2 resolvePromise.
    ]
  )
)

public class Philosopher new: name waiter: w number: d = (
| private n = name. 
  private counter ::= 0.
  private waiter = w.
  private i = d.
|)(
      public think = (
        (n + ' is thinking ') println.
        1 to: 3 do: [:j |
          counter := counter + j.
        ]
      )

      public eat = (
        (n + ' is eating ') println.
        1 to: 5 do: [:j |
          counter := counter + j.
        ]
      )

      public stop = (
        (n + ' stop ') println.
      )

      public start = (
        (n + ' start ') println.
        (self <-: think) whenResolved: [: doneThinking |
            (' ---doneThinking ' + n) println.
            (waiter <-: pickUpForks: i) whenResolved: [: donePickUp |
              (' ---donePickUp ' + n) println.
              (self <-: eat) whenResolved: [: doneEating |
                (' ---doneEating '+ n) println.
                waiter <-: putDownForks: i.
               (* self <-: start. *) 
                nil
              ]
            ]
          ]
       )
  )

  public testPhilosophers = (
  | size names philosophers waiter time pair p r cv |

    pair := actors createPromisePair.
    r := pair resolver.
    p := pair promise.
  
    size := 5.     (* number of philosophers is equals to the number of forks *)
    philosophers := Array new: size.
    waiter := Waiter new: size.
    waiter <-: initForks.

    names := Vector new.
    names append: 'Socrates'.
    names append: 'Plato'.
    names append: 'Aristotle'.
    names append: 'Democritus'.
    names append: 'Pythagoras'.

    philosophers doIndexes: [:i |
      | pName philoActor |
      pName := names at: i.
      philoActor := (actors createActorFromValue: Philosopher) <-: new: pName waiter: waiter number: i.
      philosophers at: i put: philoActor.
    ].

    ('create actors') println.

    time := 0.
    1 to: 10 do: [:i |
      time := time + i.
      time = 10
      ifTrue: [
        (* stop program *)
        1 to: size do: [:i |
          (philosophers at: i)  <-: stop.
        ].
        r resolve: true
      ]
      ifFalse: [
        1 to: size do: [:i |
          (* start cycle *) 
           (philosophers at: i)  <-: start.
        ]
      ]
    ].
    ^ p
  )

  public main: args = (
  | p |
    'Hello DiningPhilosophersApp!' println.
     p := testPhilosophers.
    'testPhilosophers Done' println.    
    ^ p
  )
)
